---
title: "FEMA_mismatch"
output: html_document
date: "2025-04-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r geodc}
library(dplyr)
library(ggplot2)
library(ggbreak)
library(sf)
library(dplyr)
library(leaflet)
library(xml2)
library(stringr)
library(rvest)
library(purrr)
library(leaflet)
library(leaflet.extras)
library(htmltools)
library(htmlwidgets)
library(tidyr)

# Load in NOAA flood data
floods <- read.csv("/Users/marleeyork/6289spatial_final/data/events_flood_df.csv")

# Aggregate floods by year
yearly_floods <- floods %>% group_by(year) %>% count()
yearly_floods <- data.frame(yearly_floods)

# Create dataframe of dates with 0 flood events included
data <- data.frame("year" = 1996:2024)
data <- merge(data, yearly_floods, by = "year", all.x = TRUE)
data$n[is.na(data$n)] <- 0

# Get range of x values for rectangle
x_min <- min(data$year - 1)
x_max <- max(data$year + 1)
```

Loading in the flood zones for DC, MD, and VA.
```{r geodc}
# Load in the flood zones
flood_zones <- read.csv("/Users/marleeyork/6289spatial_final/data/flood_insurance_hazard_all.csv")

# Convert WKT (Well-Known Text) POLYGON strings to sf objects
flood_zones <- st_as_sf(flood_zones, wkt = "geometry", crs = 4362)

# Set original CRS
flood_zones <- st_set_crs(flood_zones, 4269)

# If you need to transform to a specific CRS (e.g., to WGS 84)
flood_zones <- st_transform(flood_zones, 4326)
print(head(flood_zones))
```
Adding the flood points.

```{r geodc}
# Adding the flood points
flood_points_df <- data.frame("lat" = floods$BEGIN_LAT,
                              "lon" = floods$BEGIN_LON,
                              "year" = floods$YEAR,
                              "event_type" = floods$EVENT_TYPE,
                              "state" = floods$STATE)
flood_points_df <- na.omit(flood_points_df)
flood_points_sf <- st_as_sf(flood_points_df, coords = c("lon", "lat"), crs = 4326)

# Match CRS of flood zones
flood_points_sf <- st_transform(flood_points_sf, crs = st_crs(flood_zones))

# Check for validity
validity <- st_is_valid(flood_zones)

# If any are FALSE, fix them
flood_zones_fixed <- st_make_valid(flood_zones)
```

Adding the state boundaries to separate plots by state. Might not need this.
```{r geodc}
# Download tracts for VA
va_tracts <- read.csv("block_groups_va.csv")

# Convert WKT (Well-Known Text) POLYGON strings to sf objects
va_tracts <- st_as_sf(flood_zones, wkt = "geometry")

# Set original CRS
va_tracts <- st_set_crs(flood_zones, 4269)

# If you need to transform to a specific CRS (e.g., to WGS 84)
va_tracts <- st_transform(flood_zones, 4326)
```

Joining flood zones and points to see if events are in the zone.

```{r geodc}
# Create new column to indicate whether its in the flood zone or not
MD_floods_with_zones <- st_join(flood_points_sf, flood_zones_fixed, join = st_intersects, left = TRUE)
floods_with_zones_fixed <- st_make_valid(floods_with_zones)

# Assign flood zone status
floods_with_zones_fixed$in_flood_zone <- floods_with_zones$properties.FLD_ZONE %in% c("A", "AE", "VE")  
```

Now calculating the flood counts in each zone.
```{r geodc}
# First, add polygon identifiers to each flood zone
flood_zones_fixed <- flood_zones_fixed %>%
  mutate(polygon_id = paste0("polygon_", row_number()))

# Join flood points with specific zones
# This will associate each flood point with the specific polygon it falls within
floods_with_specific_zones <- st_join(
  floods_with_zones_fixed,
  flood_zones_fixed %>% select(polygon_id, properties.FLD_ZONE),
  left = TRUE
) %>%
  mutate(
    marker_id = paste0("marker_", row_number()),
    # If point doesn't fall within any polygon, in_flood_zone will be FALSE
    in_flood_zone = (!is.na(properties.FLD_ZONE.y) & (properties.FLD_ZONE.y != "X"))
  )

# Start with your existing data preparation
floods_with_zones_fixed <- floods_with_specific_zones %>%
  mutate(
    marker_id = paste0("marker_", row_number()),
    in_flood_zone = (!is.na(properties.FLD_ZONE.y) & (properties.FLD_ZONE.y != "X"))
  )

# Calculate statistics for each specific polygon
zone_specific_stats <- floods_with_zones_fixed %>%
  st_drop_geometry() %>%
  group_by(polygon_id) %>%
  summarise(
    FLD_ZONE = first(properties.FLD_ZONE.y),
    n_events = n(),
    n_floods = sum(if_else(event_type == "Flood", 1, 0, missing = 0)),
    n_flash = sum(if_else(event_type == "Flash Flood", 1, 0, missing = 0)),
    n_coastal = sum(if_else(event_type == "Coastal Flood", 1, 0, missing = 0))
  )

# Join these stats back to the original polygons
flood_zones_stats <- flood_zones_fixed %>%
  left_join(zone_specific_stats, by = "polygon_id") %>%
  mutate(
    n_events = replace_na(n_events, 0),
    zone_status = ifelse(n_events > 0, "In", "Out"),
  )
```

```{r geodc}
# Create zone labels
zone_labels <- c("In" = "Zone AE/A (Minimal Risk)", "Out" = "Zone X (Moderate Risk)")

# Assign zone status
flood_zones_stats$zone_status[flood_zones_stats$properties.FLD_ZONE.x=="X"] <- "Out"
flood_zones_stats$zone_status[flood_zones_stats$properties.FLD_ZONE.x!="X"] <- "In"
floods_with_zones_fixed$zone_status <- ifelse(floods_with_zones_fixed$properties.FLD_ZONE.x=="X","Out","In")

# Create color palette based on whether zone is a flood zone (Zone X) or not
pal_flood <- colorFactor(
  palette = c("Out" = "#d6c6a8", "In" = "#397fa3"),
  domain = c("Out", "In")
)

pal_zone <- colorFactor(
  palette = c("Zone AE (Moderate Risk)" = "#397fa3", "Zone X (Minimal Risk)" = "#d6c6a8"),
  domain = c("Zone AE (Moderate Risk)","Zone X (Minimal Risk)")
)

# Transform both to WGS84
flood_zones_stats <- st_transform(flood_zones_stats, crs = 4326)
floods_with_zones_fixed <- st_transform(floods_with_zones_fixed, crs = 4326)
```

```{r geodc}
# Create a lookup object for zone statistics to use in JavaScript
zone_stats_lookup <- flood_zones_stats %>%
  st_drop_geometry() %>%
  select(polygon_id, properties.FLD_ZONE, n_events) %>%
  jsonlite::toJSON()

# Add custom JavaScript for interaction
js_code <- sprintf("
function(el, x) {
  var map = this;
  
  // Parse the zone statistics lookup
  var zoneStats = %s;
  
  // Create a div for hover stats if it doesn't exist
  var statsDiv = document.getElementById('hover-stats');
  if (!statsDiv) {
    statsDiv = document.createElement('div');
    statsDiv.id = 'hover-stats';
    statsDiv.style.padding = '6px 8px';
    statsDiv.style.background = 'white';
    statsDiv.style.boxShadow = '0 0 15px rgba(0,0,0,0.2)';
    statsDiv.style.borderRadius = '5px';
    statsDiv.innerHTML = 'Hover over a zone to see statistics';
    
    var statsControl = L.control({position: 'bottomleft'});
    statsControl.onAdd = function() {
      return statsDiv;
    };
    statsControl.addTo(map);
  }
  
  // Function to update stats display
  function updateStats(polygonId) {
    for (var i = 0; i < zoneStats.length; i++) {
      if (zoneStats[i].polygon_id === polygonId) {
        var zone = zoneStats[i];
        var zoneLabel = '';
        if (zone.FLD_ZONE === 'X') zoneLabel = 'Zone X (Minimal Risk)';
        else if (zone.FLD_ZONE === 'AE') zoneLabel = 'Zone AE (High Risk)';
        else if (zone.FLD_ZONE === 'A') zoneLabel = 'Zone A (High Risk)';
        else zoneLabel = 'Zone ' + zone.FLD_ZONE;
        
        statsDiv.innerHTML = '<strong>' + zoneLabel + '</strong><br/>' +
                            'Events in this zone: ' + zone.n_events + '<br/>' +
                            'Mean depth: ' + zone.mean_depth.toFixed(2) + ' ft';
        return;
      }
    }
    // If no match found
    statsDiv.innerHTML = 'Hover over a zone to see statistics';
  }
  
  // Add event handlers to each polygon
  map.eachLayer(function(layer) {
    if (layer.options && layer.options.layerId && layer.options.layerId.startsWith('polygon_')) {
      layer.on('mouseover', function(e) {
        updateStats(layer.options.layerId);
        layer.setStyle({
          weight: 3,
          color: 'black',
          fillOpacity: 0.7
        });
        
        // Highlight all markers within this polygon
        map.eachLayer(function(markerLayer) {
          if (markerLayer.options && 
              markerLayer.options.layerId && 
              markerLayer.options.layerId.startsWith('marker_') &&
              markerLayer.feature && 
              markerLayer.feature.properties && 
              markerLayer.feature.properties.polygon_id === layer.options.layerId) {
            markerLayer.setStyle({
              radius: 7,
              fillOpacity: 1.0,
              weight: 2
            });
          }
        });
      });
      
      layer.on('mouseout', function(e) {
        statsDiv.innerHTML = 'Hover over a zone to see statistics';
        layer.setStyle({
          weight: 1,
          color: 'white',
          fillOpacity: 0.6
        });
        
        // Reset all markers
        map.eachLayer(function(markerLayer) {
          if (markerLayer.options && 
              markerLayer.options.layerId && 
              markerLayer.options.layerId.startsWith('marker_')) {
            markerLayer.setStyle({
              radius: 5,
              fillOpacity: 0.6,
              weight: 1
            });
          }
        });
      });
    }
  });
}
", zone_stats_lookup)


# Convert Date to year (assuming 'Date' contains date values)
floods_with_zones_fixed$Year <- as.numeric(format(as.Date(floods_with_zones_fixed$Date), "%Y"))

# Find min and max years for the palette
min_year <- min(floods_with_zones_fixed$Year, na.rm = TRUE)
max_year <- max(floods_with_zones_fixed$Year, na.rm = TRUE)

# 1. Year-based gradient (as discussed previously)
floods_with_zones_fixed$Year <- as.numeric(format(as.Date(floods_with_zones_fixed$Date), "%Y"))
min_year <- min(floods_with_zones_fixed$Year, na.rm = TRUE)
max_year <- max(floods_with_zones_fixed$Year, na.rm = TRUE)
pal_years <- colorNumeric(
  palette = colorRampPalette(c("blue", "red"))(n = 100),
  domain = c(min_year, max_year)
)

# 2. Zone status coloring
pal_zone_status <- colorFactor(
  palette = c("red", "black"),
  domain = c(TRUE, FALSE)
)

# Create the base map without any markers initially
# Check the geometry types
print(unique(st_geometry_type(flood_zones_stats)))

# Convert GEOMETRYCOLLECTION to POLYGON or MULTIPOLYGON
flood_zones_stats_fixed <- flood_zones_stats %>%
  st_cast("MULTIPOLYGON")

# Now try your map with the fixed data
m <- leaflet() %>%
  addTiles() %>%
  addControl(
    html = "<div id='hover-stats' style='padding: 6px 8px; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px;'>Hover over a zone to see statistics</div>",
    position = "bottomleft"
  ) %>%
  addPolygons(
    data = flood_zones_stats_fixed,  # Use the fixed data here
    fillColor = ~pal_flood(zone_status),
    fillOpacity = 0.6,
    color = "white",
    weight = 1,
    layerId = ~polygon_id,
    popup = ~paste0(
      "<strong>Zone:</strong> ", zone_labels[zone_status], "<br/>",
      "<strong>Events in this specific zone:</strong> ", n_events, "<br/>",
      "<strong>Number of each event type:</strong> ", "<br/>",
      "   Floods - </strong> ", n_floods, "<br/>",
      "   Flash floods - ", n_flash, "<br/>",
      "   Coastal floods - ", n_coastal, "<br/>"
    ),
    highlightOptions = highlightOptions(
      color = "black",
      weight = 2,
      bringToFront = TRUE
    )
  )

# Create markers for Year-based coloring
year_markers <- floods_with_zones_fixed %>%
  sf::st_transform(4326) %>%
  leaflet::leaflet() %>%
  leaflet::addCircleMarkers(
    color = ~pal_years(Year),
    radius = 5,
    stroke = TRUE,
    weight = 1,
    opacity = 1,
    fillOpacity = 0.8,
    layerId = ~paste0("year_", marker_id),
    popup = ~paste0(
      "<strong>Date:</strong> ", Date, "<br/>",
      "<strong>Year:</strong> ", Year, "<br/>",
      "<strong>In zone?</strong> ", ifelse(in_flood_zone, "Yes", "No"), "<br/>",
      "<strong>Zone polygon:</strong> ", ifelse(is.na(polygon_id), "None", polygon_id)
    ),
    group = "Color by Year"
  )

# Create markers for Zone-based coloring
zone_markers <- floods_with_zones_fixed %>%
  sf::st_transform(4326) %>%
  leaflet::leaflet() %>%
  leaflet::addCircleMarkers(
    color = ~ifelse(in_flood_zone, "red", "black"),
    radius = 5,
    stroke = TRUE,
    weight = 1,
    opacity = 1,
    fillOpacity = 0.8,
    layerId = ~paste0("zone_", marker_id),
    popup = ~paste0(
      "<strong>Date:</strong> ", Date, "<br/>",
      "<strong>In zone?</strong> ", ifelse(in_flood_zone, "Yes", "No"), "<br/>",
      "<strong>Zone polygon:</strong> ", ifelse(is.na(polygon_id), "None", polygon_id)
    ),
    group = "Color by Flood Zone"
  )

# Extract the marker data from both leaflet objects
year_marker_data <- year_markers$x$calls[[which(sapply(year_markers$x$calls, function(x) x$method == "addCircleMarkers"))]]
zone_marker_data <- zone_markers$x$calls[[which(sapply(zone_markers$x$calls, function(x) x$method == "addCircleMarkers"))]]

# Add both types of markers to the main map
m$x$calls <- c(m$x$calls, list(year_marker_data, zone_marker_data))

m <- m %>%
  # Add legend for flood zones
  addLegend(
    position = "bottomright",
    pal = pal_flood,
    values = flood_zones_stats$zone_status,
    title = "Flood Zone Type",
    opacity = 0.7,
    labFormat = labelFormat(prefix = "", transform = function(x) zone_labels[x])
  ) %>%
  # Add legend for years (initially hidden)
  addLegend(
    position = "bottomright",
    pal = pal_years,
    values = floods_with_zones_fixed$Year,
    title = "Flood Event Year",
    opacity = 0.7,
    # Simpler format that won't try to round non-numeric values
    labFormat = function(type, cuts, p) {
      paste0(format(cuts, big.mark = "", scientific = FALSE))
    },
    group = "Color by Year"
  ) %>%
  # Add legend for zone status (initially visible)
  addLegend(
    position = "bottomright",
    colors = c("red", "black"),
    labels = c("In Flood Zone", "Outside Flood Zone"),
    title = "Flood Event Location",
    opacity = 0.7,
    group = "Color by Flood Zone"
  ) %>%
  # Add layer control
  addLayersControl(
    baseGroups = c("Color by Flood Zone", "Color by Year"),
    options = layersControlOptions(collapsed = FALSE)
  )

# Add JavaScript to handle layer switching and legend visibility
js_code_layers <- "
function(el, x) {
  var map = this;
  
  // Set initial state - show 'Color by Flood Zone' and hide 'Color by Year'
  map.eachLayer(function(layer) {
    if (layer.options && layer.options.layerId) {
      if (layer.options.layerId.startsWith('year_')) {
        map.removeLayer(layer);
      }
    }
  });
  
  // Function to manage legend visibility
  function updateLegendVisibility() {
    var activeLayers = [];
    
    // Find which base layer is active
    document.querySelectorAll('.leaflet-control-layers-base input').forEach(function(input) {
      if (input.checked) {
        activeLayers.push(input.nextSibling.textContent.trim());
      }
    });
    
    // Show/hide legends based on active layer
    document.querySelectorAll('.leaflet-control-layers-overlays').forEach(function(legend) {
      if (legend.textContent.includes('Flood Event Year')) {
        legend.style.display = activeLayers.includes('Color by Year') ? 'block' : 'none';
      }
      if (legend.textContent.includes('Flood Event Location')) {
        legend.style.display = activeLayers.includes('Color by Flood Zone') ? 'block' : 'none';
      }
    });
  }
  
  // Add event listener for layer control
  var layerControl = document.querySelector('.leaflet-control-layers');
  if (layerControl) {
    layerControl.addEventListener('click', function() {
      setTimeout(updateLegendVisibility, 100);
    });
  }
  
  // Initial legend visibility
  setTimeout(updateLegendVisibility, 100);
}
"

# Append this JavaScript to the existing JS code
js_code_combined <- paste(js_code, js_code_layers, sep = "\n\n")

# Render the map with the combined JavaScript
map_with_js <- htmlwidgets::onRender(m, js_code_combined)

```

```{r geodc}
map_with_js
```