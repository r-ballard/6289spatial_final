Yo !

```{r}

library(sf)
library(plotly)
sf_use_s2(FALSE)
library(dplyr)
library(readr)
library(ggplot2)


dc <- read_csv("/Users/andrewpaladino/Downloads/block_groups_dc.csv")
va <- read_csv("/Users/andrewpaladino/Downloads/block_groups_va.csv")
md <- read_csv("/Users/andrewpaladino/Downloads/block_groups_md.csv")
osm_buildings <- read_csv("/Users/andrewpaladino/Documents/xyzeus/data/building_footprints.csv")
noaa_flood_dc <- read_csv("/Users/andrewpaladino/Downloads/noaa_flood_dc.csv")
storm_data <- read_delim("/Users/andrewpaladino/Downloads/storm_details_dmv.csv", delim = "|")

bg_total <- bind_rows(dc, va, md)
bg_total_geo <- st_as_sf(bg_total, wkt = "geometry", crs = 4326)
bg_total_geo <- bg_total_geo %>%
  mutate(census_geometry = geometry)
bg_total_geo <- st_make_valid(bg_total_geo)

storm_data <- storm_data %>%
  filter(!is.na(BEGIN_LAT) & !is.na(BEGIN_LON))

storm_data_geo <- st_as_sf(storm_data, coords = c("BEGIN_LON", "BEGIN_LAT"), crs = 4326)
census_stormdata <- st_join(storm_data_geo, bg_total_geo, join = st_within)

census_stormdata <- census_stormdata %>%
  mutate(
    county_code = paste0(`attributes.STATE`, `attributes.COUNTY`),
    tract_code = paste0(`attributes.STATE`, `attributes.COUNTY`, `attributes.TRACT`)
  )

census_stormdata$BEGIN_DATE_TIME <- as.POSIXct(
  census_stormdata$BEGIN_DATE_TIME,
  format = "%d-%b-%y %H:%M:%S",
  tz = "UTC"
)

############################################################################
##### Mapping State Name and County Names to begin lat / begin long ########
############################################################################


# 1. Create the FIPS to State mapping
fips_to_state <- c(
  `11` = "DISTRICT OF COLUMBIA",
  `24` = "MARYLAND",
  `51` = "VIRGINIA"
)

# 2. Create Virginia, Maryland, and DC counties as dataframes
va_counties <- tibble(
  attributes.COUNTY = c(1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29,
                        31, 33, 35, 36, 37, 41, 43, 45, 47, 49, 51, 53, 57, 59, 61,
                        63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91,
                        93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117,
                        119, 121, 125, 127, 131, 133, 135, 137, 139, 141, 143, 145,
                        147, 149, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171,
                        173, 175, 177, 179, 181, 183, 185, 187, 191, 193, 195, 197,
                        199, 510, 520, 530, 540, 550, 570, 590, 610, 620, 630, 640,
                        650, 660, 670, 680, 683, 690, 700, 710, 720, 730, 735, 740,
                        750, 760, 770, 775, 790, 800, 810, 820, 830, 840),
  County_Name = c(
    "Accomack", "Albemarle", "Alleghany", "Amelia", "Amherst",
    "Appomattox", "Arlington", "Augusta", "Bath", "Bedford",
    "Bland", "Botetourt", "Brunswick", "Buchanan", "Buckingham",
    "Campbell", "Caroline", "Carroll", "Charles City", "Charlotte",
    "Chesterfield", "Clarke", "Craig", "Culpeper", "Cumberland",
    "Dickenson", "Dinwiddie", "Essex", "Fairfax", "Fauquier",
    "Floyd", "Fluvanna", "Franklin", "Frederick", "Giles",
    "Gloucester", "Goochland", "Grayson", "Greene", "Greensville",
    "Halifax", "Hanover", "Henrico", "Henry", "Highland",
    "Isle of Wight", "James City", "King and Queen", "King George",
    "King William", "Lancaster", "Lee", "Loudoun", "Louisa",
    "Lunenburg", "Madison", "Mathews", "Mecklenburg", "Middlesex",
    "Montgomery", "Nelson", "New Kent", "Northampton", "Northumberland",
    "Nottoway", "Orange", "Page", "Patrick", "Pittsylvania",
    "Powhatan", "Prince Edward", "Prince George", "Prince William",
    "Pulaski", "Rappahannock", "Richmond", "Roanoke", "Rockbridge",
    "Rockingham", "Russell", "Scott", "Shenandoah", "Smyth",
    "Southampton", "Spotsylvania", "Stafford", "Surry", "Sussex",
    "Tazewell", "Warren", "Washington", "Westmoreland", "Wise",
    "Wythe", "York", "Alexandria City", "Bristol City", "Buena Vista City",
    "Charlottesville City", "Chesapeake City", "Colonial Heights City",
    "Danville City", "Falls Church City", "Franklin City", "Fredericksburg City",
    "Galax City", "Hampton City", "Harrisonburg City", "Hopewell City",
    "Lynchburg City", "Manassas City", "Martinsville City", "Newport News City",
    "Norfolk City", "Norton City", "Petersburg City", "Poquoson City",
    "Portsmouth City", "Radford City", "Richmond City", "Roanoke City",
    "Salem City", "Staunton City", "Suffolk City", "Virginia Beach City",
    "Waynesboro City", "Williamsburg City", "Winchester City"
  ),
  attributes.STATE = 51
)

md_counties <- tibble(
  attributes.COUNTY = c(1, 3, 5, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31,
                        33, 35, 37, 39, 41, 43, 45, 47, 510),
  County_Name = c(
    "Allegany", "Anne Arundel", "Baltimore", "Calvert", "Caroline",
    "Carroll", "Cecil", "Charles", "Dorchester", "Frederick",
    "Garrett", "Harford", "Howard", "Kent", "Montgomery",
    "Prince Georges", "Queen Annes", "St. Marys", "Somerset",
    "Talbot", "Washington", "Wicomico", "Worcester", "Baltimore City"
  ),
  attributes.STATE = 24
)

dc_county <- tibble(
  attributes.COUNTY = 1,
  County_Name = "District of Columbia",
  attributes.STATE = 11
)

# 3. Combine all into one lookup
county_lookup <- bind_rows(va_counties, md_counties, dc_county)

# 4. Map State Name
census_stormdata <- census_stormdata %>%
  mutate(STATE_MAPPED = recode(as.character(attributes.STATE), !!!fips_to_state)) %>%
  mutate(attributes.COUNTY = as.numeric(attributes.COUNTY))

# 5. Merge county names
census_stormdata <- census_stormdata %>%
  left_join(county_lookup, by = c("attributes.STATE", "attributes.COUNTY"))

#########################################
###########. solely flooding events #####
#########################################

library(stringr)

# Define regex pattern
flood_keywords <- "flood|flash flood|flooding"

# Filter flood-related events
flood_events <- census_stormdata %>%
  filter(
    str_detect(EVENT_TYPE, regex(flood_keywords, ignore_case = TRUE)) |
    str_detect(EPISODE_NARRATIVE, regex(flood_keywords, ignore_case = TRUE)) |
    str_detect(EVENT_NARRATIVE, regex(flood_keywords, ignore_case = TRUE))
  )


#####################################
###########. aggregate event counts #
#####################################


# By YEAR, GIDBG, and census_geometry
bg_group <- census_stormdata %>%
  group_by(YEAR, GIDBG, census_geometry) %>%
  summarize(event_count = n(), .groups = "drop")

bg_group_flood <- flood_events %>%
  group_by(YEAR, GIDBG, census_geometry) %>%
  summarize(event_count = n(), .groups = "drop")

# Total events per GIDBG and census_geometry
sum_bg_group <- bg_group %>%
  group_by(GIDBG, census_geometry) %>%
  summarize(total_events = sum(event_count), .groups = "drop")

sum_bg_group_flood <- bg_group_flood %>%
  group_by(GIDBG, census_geometry) %>%
  summarize(total_events = sum(event_count), .groups = "drop")

# By YEAR and tract_code
tract_group <- census_stormdata %>%
  group_by(YEAR, tract_code) %>%
  summarize(event_count = n(), .groups = "drop")

tract_group_flood <- flood_events %>%
  group_by(YEAR, tract_code) %>%
  summarize(event_count = n(), .groups = "drop")

# By YEAR and county_code
county_group <- census_stormdata %>%
  group_by(YEAR, county_code) %>%
  summarize(event_count = n(), .groups = "drop")

county_group_flood <- flood_events %>%
  group_by(YEAR, county_code) %>%
  summarize(event_count = n(), .groups = "drop")

# By YEAR and STATE
state_group <- census_stormdata %>%
  group_by(YEAR, STATE) %>%
  summarize(event_count = n(), .groups = "drop")

state_group_flood <- flood_events %>%
  group_by(YEAR, STATE) %>%
  summarize(event_count = n(), .groups = "drop")


```

# PLOTS

```{r}

ggplot(bg_group, aes(x = YEAR, y = event_count, color = GIDBG, group = GIDBG)) +
  geom_line() +
  geom_point() +
  labs(title = "Event Count by GIDBG", x = "Year", y = "Event Count") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.key.size = unit(0.3, "cm"),
    legend.text = element_text(size = 6)
  ) +
  guides(color = guide_legend(nrow = 3, byrow = TRUE))

ggplot(bg_group_flood, aes(x = YEAR, y = event_count, color = GIDBG, group = GIDBG)) +
  geom_line() +
  geom_point() +
  labs(title = "Event Count by GIDBG", x = "Year", y = "Event Count") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.key.size = unit(0.3, "cm"),
    legend.text = element_text(size = 6)
  ) +
  guides(color = guide_legend(nrow = 3, byrow = TRUE))

```

```{r}

ggplot(tract_group, aes(x = YEAR, y = event_count, color = tract_code, group = tract_code)) +
  geom_line() +
  geom_point() +
  labs(title = "Event Count by Tract", x = "Year", y = "Event Count") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.key.size = unit(0.3, "cm"),
    legend.text = element_text(size = 6)
  ) +
  guides(color = guide_legend(nrow = 3, byrow = TRUE))

ggplot(tract_group_flood, aes(x = YEAR, y = event_count, color = tract_code, group = tract_code)) +
  geom_line() +
  geom_point() +
  labs(title = "Event Count by Tract", x = "Year", y = "Event Count") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.key.size = unit(0.3, "cm"),
    legend.text = element_text(size = 6)
  ) +
  guides(color = guide_legend(nrow = 3, byrow = TRUE))

```

```{r}

ggplot(county_group, aes(x = YEAR, y = event_count, color = county_code, group = county_code)) +
  geom_line() +
  geom_point() +
  labs(title = "Event Count by Tract", x = "Year", y = "Event Count") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.key.size = unit(0.3, "cm"),
    legend.text = element_text(size = 6)
  ) +
  guides(color = guide_legend(nrow = 3, byrow = TRUE))


ggplot(county_group_flood, aes(x = YEAR, y = event_count, color = county_code, group = county_code)) +
  geom_line() +
  geom_point() +
  labs(title = "Event Count by County", x = "Year", y = "Event Count") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.key.size = unit(0.3, "cm"),
    legend.text = element_text(size = 6)
  ) +
  guides(color = guide_legend(nrow = 3, byrow = TRUE))


```

```{r}

ggplot(state_group, aes(x = YEAR, y = event_count, color = STATE, group = STATE)) +
  geom_line() +
  geom_point() +
  labs(title = "Event Count by Tract", x = "Year", y = "Event Count") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.key.size = unit(0.3, "cm"),
    legend.text = element_text(size = 6)
  ) +
  guides(color = guide_legend(nrow = 3, byrow = TRUE))

ggplot(state_group_flood, aes(x = YEAR, y = event_count, color = STATE, group = STATE)) +
  geom_line() +
  geom_point() +
  labs(title = "Event Count by State", x = "Year", y = "Event Count") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    legend.key.size = unit(0.3, "cm"),
    legend.text = element_text(size = 6)
  ) +
  guides(color = guide_legend(nrow = 3, byrow = TRUE))


```

```{r, fig.width=10, fig.height=8}

ggplot(sum_bg_group) +
  geom_sf(aes(fill = total_events), color = NA, size = 0.4) +
  scale_fill_viridis_c(option = "plasma", name = "Event Count") +
  labs(
    title = "Total Events per Block Group",
    subtitle = "GIDBG-level Choropleth",
    caption = "Data Source: Your Project"
  ) +
  theme_minimal()


ggplot(sum_bg_group_flood) +
  geom_sf(aes(fill = total_events), color = NA, size = 0.4) +
  scale_fill_viridis_c(option = "plasma", name = "Event Count") +
  labs(
    title = "Total Events per Block Group",
    subtitle = "GIDBG-level Choropleth",
    caption = "Data Source: Your Project"
  ) +
  theme_minimal()


```

```{r}

```

```{r}

#install.packages("gganimate")
#install.packages("transformr")  # needed for transitions
#install.packages("gifski")
#install.packages("png")
#install.packages("av")
#install.packages("ggspatial")
#install.packages("rosm")

library(ggplot2)
library(gganimate)
library(sf)


all_events_ani <- ggplot(bg_group) +
  geom_sf(data = bg_total_geo, fill = NA, color = "white", size = 0.2) +  # <- outline layer
  geom_sf(aes(fill = event_count), color = NA) +
  scale_fill_viridis_c(option = "plasma", name = "Event Count") +
  labs(
    title = 'Event Count by Block Group — Year: {current_frame}',
    subtitle = "Animated Choropleth",
    caption = "Data Source: Your Project"
  ) +
  theme_minimal() +
  transition_manual(frames = YEAR)



flood_events_ani <- ggplot(bg_group_flood) +
  geom_sf(data = bg_total_geo, fill = NA, color = "grey", size = 0.05) +  # <- outline layer
  geom_sf(aes(fill = event_count), color = NA) +
  scale_fill_viridis_c(option = "plasma", name = "Event Count") +
  labs(
    title = 'Flood Event Count by Block Group — Year: {current_frame}',
    subtitle = "Animated Choropleth",
    caption = "Data Source: Your Project"
  ) +
  theme_minimal() +
  transition_manual(frames = YEAR)


```

```{r}
#animate(all_events_ani, width = 1000, height = 800, fps = 2, renderer = gifski_renderer())
animate(flood_events_ani, width = 1000, height = 800, fps = 2, renderer = gifski_renderer())

```

#### different maps and casualties, different things with flood events

###### join on events, flood hazard ---- determine % of events fall within and % of events fall outside flood zones... this will determine if flood zones need remapped \### /Users/andrewpaladino/Documents/xyzeus/data/flood_insurance_hazard_all.csv

###### join on flood hazard, census tracts ... maybe??

# event type

# damage property

# damage crops

# margnitude

# deaths direct

# deaths indirect

# injuries direct

# injuries indirect

```{r}

```

# FLOOD DAMAGE PROPERTY

```{r}

# 1. Filter non-missing DAMAGE_PROPERTY
flood_events_damage <- flood_events %>%
  filter(!is.na(DAMAGE_PROPERTY))

# 2. Convert DAMAGE_PROPERTY to numeric (handles K, M, B)
flood_events_damage <- flood_events_damage %>%
  mutate(
    DAMAGE_PROPERTY_NUM = case_when(
      str_detect(DAMAGE_PROPERTY, "K") ~ as.numeric(str_replace(DAMAGE_PROPERTY, "K", "")) * 1e3,
      str_detect(DAMAGE_PROPERTY, "M") ~ as.numeric(str_replace(DAMAGE_PROPERTY, "M", "")) * 1e6,
      str_detect(DAMAGE_PROPERTY, "B") ~ as.numeric(str_replace(DAMAGE_PROPERTY, "B", "")) * 1e9,
      TRUE ~ as.numeric(DAMAGE_PROPERTY)
    )
  )

# 3. Group and summarize, then remove zero-damage geometries
flood_events_damage_group <- flood_events_damage %>%
  group_by(GIDBG, census_geometry) %>%
  summarise(sumtotal_damage = sum(DAMAGE_PROPERTY_NUM, na.rm = TRUE), .groups = "drop") %>%
  filter(sumtotal_damage > 0)  # <- remove zeros

# 4. Sort descending by damage
flood_events_damage_group <- flood_events_damage_group %>%
  arrange(desc(sumtotal_damage))

ggplot(flood_events_damage_group) +
  geom_sf(aes(fill = sumtotal_damage), color = NA, size = 10) +
  scale_fill_viridis_c(option = "plasma", name = "Damage Totals") +
  labs(
    title = "Total Property Damage per Block Group",
    subtitle = "GIDBG-level Choropleth",
    caption = "Data Source: Your Project"
  ) +
  theme_minimal()




```

# Flood Damage Crops

```{r}

# 1. Filter non-missing DAMAGE_CROPS
flood_events_crop <- flood_events %>%
  filter(!is.na(DAMAGE_CROPS))

# 2. Convert DAMAGE_CROPS to numeric
flood_events_crop <- flood_events_crop %>%
  mutate(
    DAMAGE_CROPS_NUM = case_when(
      str_detect(DAMAGE_CROPS, "K") ~ as.numeric(str_replace(DAMAGE_CROPS, "K", "")) * 1e3,
      str_detect(DAMAGE_CROPS, "M") ~ as.numeric(str_replace(DAMAGE_CROPS, "M", "")) * 1e6,
      str_detect(DAMAGE_CROPS, "B") ~ as.numeric(str_replace(DAMAGE_CROPS, "B", "")) * 1e9,
      TRUE ~ as.numeric(DAMAGE_CROPS)
    )
  )

# 3. Group by GIDBG and census_geometry, summarize total crop damage, remove zeros
flood_events_crop_group <- flood_events_crop %>%
  group_by(GIDBG, census_geometry) %>%
  summarise(sumtotal_crop_damage = sum(DAMAGE_CROPS_NUM, na.rm = TRUE), .groups = "drop") %>%
  filter(sumtotal_crop_damage > 0)

# 4. Sort descending
flood_events_crop_group <- flood_events_crop_group %>%
  arrange(desc(sumtotal_crop_damage))

ggplot(flood_events_crop_group) +
  geom_sf(aes(fill = sumtotal_crop_damage), color = NA, size = 0.1) +
  scale_fill_viridis_c(option = "plasma", name = "Crop Damage Totals") +
  labs(
    title = "Total Crop Damage per Block Group",
    subtitle = "GIDBG-level Choropleth",
    caption = "Data Source: Your Project"
  ) +
  theme_minimal()


```

# Magnitude

```{r}

# 1. Filter non-missing MAGNITUDE
flood_events_mag <- flood_events %>%
  filter(!is.na(MAGNITUDE))

# 2. Group and summarize average magnitude
flood_events_mag_group <- flood_events_mag %>%
  group_by(GIDBG, census_geometry) %>%
  summarise(avg_magnitude = mean(MAGNITUDE, na.rm = TRUE), .groups = "drop") %>%
  filter(avg_magnitude > 0)

# 3. Sort descending
flood_events_mag_group <- flood_events_mag_group %>%
  arrange(desc(avg_magnitude))

ggplot(flood_events_mag_group) +
  geom_sf(aes(fill = avg_magnitude), color = NA, size = 0.1) +
  scale_fill_viridis_c(option = "plasma", name = "Avg. Magnitude") +
  labs(
    title = "Average Event Magnitude per Block Group",
    subtitle = "GIDBG-level Choropleth",
    caption = "Data Source: Your Project"
  ) +
  theme_minimal()
```

# Injuries and Deaths

```{r}

flood_events

```

# Summary Tables Total Events

```{r}

library(dplyr)

# Grouping by full granularity: state, county, tract, block group
total_events_block <- census_stormdata %>%
  group_by(STATE_MAPPED, attributes.STATE, County_Name, attributes.COUNTY, attributes.TRACT, attributes.BLKGRP) %>%
  summarise(total_event_count_per_block = n(), .groups = "drop") %>%
  arrange(desc(total_event_count_per_block))

# Grouping by tract
total_events_tracks <- census_stormdata %>%
  group_by(STATE_MAPPED, attributes.STATE, County_Name, attributes.COUNTY, attributes.TRACT) %>%
  summarise(total_event_count_per_tract = n(), .groups = "drop") %>%
  arrange(desc(total_event_count_per_tract))

# Grouping by county
total_events_county <- census_stormdata %>%
  group_by(STATE_MAPPED, attributes.STATE, County_Name, attributes.COUNTY) %>%
  summarise(total_event_count_per_county = n(), .groups = "drop") %>%
  arrange(desc(total_event_count_per_county))

# Grouping by state only
total_events_state <- census_stormdata %>%
  group_by(STATE_MAPPED, attributes.STATE) %>%
  summarise(total_event_count_per_state = n(), .groups = "drop") %>%
  arrange(desc(total_event_count_per_state))

total_events_block
total_events_tracks
total_events_county
total_events_state


```

# Summary Table Flood Events

```{r}
library(dplyr)

# Block group level (STATE, COUNTY, TRACT, BLOCK GROUP)
flood_events_blocks <- flood_events %>%
  group_by(STATE_MAPPED, attributes.STATE, County_Name, attributes.COUNTY, attributes.TRACT, attributes.BLKGRP) %>%
  summarise(`Flood Event Count Per Block Group` = n(), .groups = "drop") %>%
  arrange(desc(`Flood Event Count Per Block Group`))

# Tract level (STATE, COUNTY, TRACT)
flood_events_tracts <- flood_events %>%
  group_by(STATE_MAPPED, attributes.STATE, County_Name, attributes.COUNTY, attributes.TRACT) %>%
  summarise(`Flood Event Count per Tract` = n(), .groups = "drop") %>%
  arrange(desc(`Flood Event Count per Tract`))

# County level (STATE, COUNTY)
flood_events_counties <- flood_events %>%
  group_by(STATE_MAPPED, attributes.STATE, County_Name, attributes.COUNTY) %>%
  summarise(`Flood Event Count per County` = n(), .groups = "drop") %>%
  arrange(desc(`Flood Event Count per County`))

# State level (STATE)
flood_events_states <- flood_events %>%
  group_by(STATE_MAPPED, attributes.STATE) %>%
  summarise(`Flood Event Count per State` = n(), .groups = "drop") %>%
  arrange(desc(`Flood Event Count per State`))

flood_events_blocks
flood_events_tracts
flood_events_counties
flood_events_states
```

```{r}

write.csv(flood_events, "/Users/andrewpaladino/Downloads/flood_events.csv", row.names = FALSE)

 


```





```{r}
library(sf)
library(dplyr)
library(readr)
library(tidyr)

path <- "/Users/andrewpaladino/Documents/xyzeus/data/flood_insurance_hazard_all.csv"
flood_hazard <- read_csv(path)

flood_hazard <- flood_hazard %>%
  filter(`properties.SFHA_TF` == "T")

flood_hazard <- flood_hazard %>%
  mutate(geometry = st_as_sfc(geometry, crs = 4326))
flood_hazard_geo <- st_as_sf(flood_hazard, crs = 4326)
flood_hazard_geo <- flood_hazard_geo %>%
  select(-any_of(c("index_left", "index_right")))
flood_events <- flood_events %>%
  select(-any_of(c("index_left", "index_right")))
flood_events_flood_hazard <- st_join(flood_events, flood_hazard_geo, join = st_within, left = TRUE)


flood_summary <- flood_events_flood_hazard %>%
  group_by(GIDBG, census_geometry) %>%
  summarise(
    total_flood_events = n(),
    unique_flood_zones = n_distinct(`properties.DFIRM_ID`, na.rm = TRUE),
    unique_zone_types = list(unique(na.omit(`properties.FLD_ZONE`))),
    unique_flooding_risk_types = list(unique(na.omit(`properties.esri_symbology`))),
    .groups = "drop"
  )


flood_summary_gdf <- st_as_sf(flood_summary, crs = 4326)
flood_hazard_geo_proj <- st_transform(flood_hazard_geo, crs = 6933)
flood_summary_gdf_proj <- st_transform(flood_summary_gdf, crs = 6933)
flood_hazard_clipped <- st_intersection(
  flood_hazard_geo_proj, 
  st_geometry(flood_summary_gdf_proj)  # <- THIS IS THE KEY 🔥
)
flood_hazard_clipped <- st_sf(flood_hazard_clipped) %>%
  mutate(clipped_area = st_area(geometry))
flood_hazard_clipped <- st_join(flood_hazard_clipped, flood_summary_gdf_proj, join = st_within, left = TRUE)


flood_zone_area_summary <- flood_hazard_clipped %>%
  st_drop_geometry() %>%      # <- THIS FIXES IT: remove sf before joining
  group_by(GIDBG) %>%
  summarise(total_flood_zone_area = sum(clipped_area, na.rm = TRUE), .groups = "drop")

final_summary <- flood_summary_gdf %>%
  left_join(flood_zone_area_summary, by = "GIDBG") %>%
  mutate(total_flood_zone_area = replace_na(total_flood_zone_area, units::set_units(0, "m^2")))

```
```{r}
final_summary
```


